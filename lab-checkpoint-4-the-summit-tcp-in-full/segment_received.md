# segment\_received

segment的接收函数，接收对方传来的segment并进行状态的转移

* 在接收到segment时，\_timecnt置为0
* 在接收到rst报文时，如果当前状态为listen(初始状态)，忽略rst标志。其他情况下，一旦接收到rst标志，就要关闭连接，active置为false，inbound\_string和outbound\_string都要设为error状态
* 调用\_receiver的segment\_received函数接收该条segment
* 如果segment的ack标志有效，则还需要调用\_sender的ack\_received函数是\_sender接收该条应答报文
* 收到syn时。若为syn\_sent，如果为ack报文，则说明对方收到了己方的syn并回复sa，己方可直接进入establish状态，并给对方回复ack；若为syn但不是ack，且自己为syn\_sent状态，说明对方发送了一个syn报文请求开启连接，则己方转为syn\_recv状态，并回复一个ack，解释如下:情况1.对方未收到自己之前发送的syn(丢失)，则此情况相当于自己处于初始状态并且由对方开启连接。情况2：对方在自己发送的syn还未到达时也发送了syn，这种情况下对双方来说都是情况一，也可以建立连接。
* 对建立连接的总结：建立连接的核心在于确认对方收到了自己发的syn，一旦确认对方收到了自己的syn并且自己也收到了对方的syn就可直接回复一个ack后进入连接状态，虽然暂时还未确认对方收到自己的ack，但已经知道双方都开启了连接，之后在超时重传以及receiver的特性等机制作用下便已经可以开始传输。
* 被动关闭：在收到对方的fin后，回复ack，进入CLOSE\_WAIT状态，linger\_after\_stream\_finish = false（收到fin意味着对方已经停止发送数据），等待己方输入结束调用end\_input\_stream函数结束输入，向对方发送fin并进入LAST\_ACK状态，等待对方接收到自己的fin并回复ack后，由于知道对方已经停止发送信息所以可以不等待直接退出。
* 主动关闭：己方确认停止输出，向对方发送fin准备关闭连接，此时己方既需等待对方的fin也需等待对方对自己的fin的确认，己方只有在既确认对方知道自己发送了fin，又确认对方也发送了fin的情况下进入time\_wait状态，在进入time\_wait状态后，进行一定时间的等待，若对方一直无应答，则可认为对方已经收到了自己对对方fin的回应，则直接关闭即可。
* 对关闭的总结：在关闭时，双方都必须确认对方收到了自己的fin，以及必须收到对方的fin确认对方也发送了关闭请求，那么关闭剩下的问题就是确认对方收到自己对于对方fin的确认ack报文。被动关闭方通过接收对方的ack请求来完成这一点，既在LAST\_ACK状态下接收到ack就关闭，而主动关闭方采取长时间等待的方式，如果对方一直没有新的报文传来，则说明对方已经收到了己方的ack从而关闭了，那么己方可以立即关闭。
